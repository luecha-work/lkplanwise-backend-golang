// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: budget_plan.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createBudgetPlan = `-- name: CreateBudgetPlan :one
INSERT INTO "BudgetPlan" ("Id", "AccountId", "Month", "TotalIncome", "TotalExpenses", "SavingsGoal", "CreatedAt", "UpdatedAt", "CreatedBy", "UpdatedBy")
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING "Id", "AccountId", "Month", "TotalIncome", "TotalExpenses", "SavingsGoal", "CreatedAt", "UpdatedAt", "CreatedBy", "UpdatedBy"
`

type CreateBudgetPlanParams struct {
	Id            uuid.UUID          `json:"Id"`
	AccountId     uuid.UUID          `json:"AccountId"`
	Month         pgtype.Text        `json:"Month"`
	TotalIncome   pgtype.Numeric     `json:"TotalIncome"`
	TotalExpenses pgtype.Numeric     `json:"TotalExpenses"`
	SavingsGoal   pgtype.Numeric     `json:"SavingsGoal"`
	CreatedAt     pgtype.Timestamptz `json:"CreatedAt"`
	UpdatedAt     pgtype.Timestamptz `json:"UpdatedAt"`
	CreatedBy     pgtype.Text        `json:"CreatedBy"`
	UpdatedBy     pgtype.Text        `json:"UpdatedBy"`
}

func (q *Queries) CreateBudgetPlan(ctx context.Context, arg CreateBudgetPlanParams) (BudgetPlan, error) {
	row := q.db.QueryRow(ctx, createBudgetPlan,
		arg.Id,
		arg.AccountId,
		arg.Month,
		arg.TotalIncome,
		arg.TotalExpenses,
		arg.SavingsGoal,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i BudgetPlan
	err := row.Scan(
		&i.Id,
		&i.AccountId,
		&i.Month,
		&i.TotalIncome,
		&i.TotalExpenses,
		&i.SavingsGoal,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const deleteBudgetPlan = `-- name: DeleteBudgetPlan :exec
DELETE FROM "BudgetPlan" WHERE "Id" = $1
`

func (q *Queries) DeleteBudgetPlan(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteBudgetPlan, id)
	return err
}

const getAllBudgetPlans = `-- name: GetAllBudgetPlans :many
SELECT "Id", "AccountId", "Month", "TotalIncome", "TotalExpenses", "SavingsGoal", "CreatedAt", "UpdatedAt", "CreatedBy", "UpdatedBy" FROM "BudgetPlan"
`

func (q *Queries) GetAllBudgetPlans(ctx context.Context) ([]BudgetPlan, error) {
	rows, err := q.db.Query(ctx, getAllBudgetPlans)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BudgetPlan{}
	for rows.Next() {
		var i BudgetPlan
		if err := rows.Scan(
			&i.Id,
			&i.AccountId,
			&i.Month,
			&i.TotalIncome,
			&i.TotalExpenses,
			&i.SavingsGoal,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBudgetPlanById = `-- name: GetBudgetPlanById :one
SELECT "Id", "AccountId", "Month", "TotalIncome", "TotalExpenses", "SavingsGoal", "CreatedAt", "UpdatedAt", "CreatedBy", "UpdatedBy" FROM "BudgetPlan" WHERE "Id" = $1
`

func (q *Queries) GetBudgetPlanById(ctx context.Context, id uuid.UUID) (BudgetPlan, error) {
	row := q.db.QueryRow(ctx, getBudgetPlanById, id)
	var i BudgetPlan
	err := row.Scan(
		&i.Id,
		&i.AccountId,
		&i.Month,
		&i.TotalIncome,
		&i.TotalExpenses,
		&i.SavingsGoal,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const updateBudgetPlan = `-- name: UpdateBudgetPlan :one
UPDATE "BudgetPlan"
SET "Month" = $2, "TotalIncome" = $3, "TotalExpenses" = $4, "SavingsGoal" = $5, "UpdatedAt" = $6, "UpdatedBy" = $7
WHERE "Id" = $1
RETURNING "Id", "AccountId", "Month", "TotalIncome", "TotalExpenses", "SavingsGoal", "CreatedAt", "UpdatedAt", "CreatedBy", "UpdatedBy"
`

type UpdateBudgetPlanParams struct {
	Id            uuid.UUID          `json:"Id"`
	Month         pgtype.Text        `json:"Month"`
	TotalIncome   pgtype.Numeric     `json:"TotalIncome"`
	TotalExpenses pgtype.Numeric     `json:"TotalExpenses"`
	SavingsGoal   pgtype.Numeric     `json:"SavingsGoal"`
	UpdatedAt     pgtype.Timestamptz `json:"UpdatedAt"`
	UpdatedBy     pgtype.Text        `json:"UpdatedBy"`
}

func (q *Queries) UpdateBudgetPlan(ctx context.Context, arg UpdateBudgetPlanParams) (BudgetPlan, error) {
	row := q.db.QueryRow(ctx, updateBudgetPlan,
		arg.Id,
		arg.Month,
		arg.TotalIncome,
		arg.TotalExpenses,
		arg.SavingsGoal,
		arg.UpdatedAt,
		arg.UpdatedBy,
	)
	var i BudgetPlan
	err := row.Scan(
		&i.Id,
		&i.AccountId,
		&i.Month,
		&i.TotalIncome,
		&i.TotalExpenses,
		&i.SavingsGoal,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}
